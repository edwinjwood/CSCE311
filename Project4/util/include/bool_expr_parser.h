// Copyright CSCE 311 Spring 2025
//
// Code generated by ChatGPT in response to assignment prompt.
//
// The Generative AI has produced what is known as a
//   Top-down recursive descent parser
// To be fair, this is overkill for the assignment, but if interested, it is
// parsing a grammer based on the following grammar rules/description:
//
//   Expression -> Term { "+" Term }
//   Term -> Factor { "*" Factor }
//   Factor -> Variable ["'"]
//   Variable -> [a-z]
//

#ifndef UTIL_INCLUDE_BOOL_EXPR_PARSER_H_
#define UTIL_INCLUDE_BOOL_EXPR_PARSER_H_


#include <cstddef>
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

//
// Iterate over character array to return a string with all "delims" removed. A
// more correct version would return an std::vector<std::string> to admit to
// the possibility of multi-character tokens, but for our usage this suffices.
//
const std::string Explode(const char input[], char delim = ' ');


//
// Attempts 2^n evaluations to determine if there exists a variable assignment
// that satisfies (makes true) the boolean expression in the given string.
//
// Variable names are assumed to be 'a', 'b', ..., up to char('a' + (n - 1)).
//
// Returns true if a satisfying assignment exists, false otherwise.
//
bool SatSolver(std::size_t n, const std::string& expression);


//
// Constructs a map from the characters a, b, c, ... x, y, z, one for each
// Boolean value supplied.
//
const std::unordered_map<char, bool> BuildMap(const std::string& boolean_values);


//
// A Boolean expression parser, capable of parsing variables, a-z, ORs +,
// ANDs *, and complemented variables, e.g., a' or z'.
//
typedef std::unordered_map<char, bool> ValueMap;
class BooleanExpressionParser {
 public:
  explicit BooleanExpressionParser(const std::string& expr)
      : expression_(expr), values_(nullptr), current_index_(0),
        has_error_(0), err_msg_("") {
    // empty
  }


  BooleanExpressionParser(const std::string& expression,
                          const ValueMap& values)
    : expression_(expression), values_(&values), current_index_(0),
      has_error_(0), err_msg_("") {
    // empty
  }

  bool Parse(const std::unordered_map<char, bool>& values);

  bool Parse();

  bool HasError() const;

  const std::string Error() const;

  const std::string Expression() const {
    return expression_;
  }

 private:
  // Get the current character
  char CurrentChar() const;

  // Advance to the next character
  void Consume();

  // Parse OR ('+') expressions
  bool ParseExpr();

  // Parse AND ('*') expressions
  bool ParseTerm();

  // Parse primary values: variables (a-z), optionally negated with `'`
  bool ParseFactor();

  void ReportError(const std::string& message);


  std::string expression_;
  const std::unordered_map<char, bool>* values_;
  size_t current_index_;
  bool has_error_;
  std::string err_msg_;
};


#endif  // UTIL_INCLUDE_BOOL_EXPR_PARSER_H_
